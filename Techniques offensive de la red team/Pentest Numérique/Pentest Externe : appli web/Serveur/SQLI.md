**--page de garde de diapo--**

Une injection SQL se produit lorsqu'un individu malveillant envoie une commande SQL malformée à une application qui l'exécute ensuite sur une base de données. 
Cela peut permettre à un attaquant de récupérer des informations sensibles, d'altérer ou de supprimer des données, ou même d'exécuter des commandes sur le système hôte.
Les injections SQL sont l'une des vulnérabilités les plus courantes et les plus dangereuses pour les applications Web. Elles sont classés 3ème des Common Weakness Enumeration (CWE).

***Changement de page de diapo***

prenons l'URL suivant :
https://site-e-commerce.com/produit?category=vetements

Sur le serveur de base de données la requete ressemblerai à cela :

SELECT * FROM produit WHERE category = 'vetements' AND released = 1

SELECT *                         => selectionne tous les produits 
FROM produit                     => de la table 'produit'
WHERE category = 'vetements' 
AND released = 1                    => ou l'élément 'category' correspond à 'vetements'

Si l'entrée utilisateur n'est pas nettoyé l'attaquant pourrait modifier la requete pour extraire des données qui sont suseptible de l'interressé :

**changement de diapo**

par exemple avec cet URL qui contient une injection de code malveillant :

https://site-e-commerce.com/produit?category=vetements'--

La nouvelle requete faite au serveur SQL serait la suivante :
SELECT * FROM produit WHERE category = 'vetements'-- 

La partie injecté par l'attaquant est un commentaire et il permet d'arreter le processus de recherche de la base de données car après le commmentaire le serveur ne continue pas d'appliquer la requete SQL.

**changement de diapo**

Un autre exemple concrait serait de s'identifier en tant qu'admin sans même avoir le mot de passe en notre possession :

lors de l'authentification, l'utilisateur qui aurait une mire de login comme celle-ci : 

--capture d'écran hackazon--

émet une requete SQL comme celle-ci :

SELECT nom, prenom FROM utilisateur WHERE username = 'utilisateur1' AND password = 'P@ssword'

Mais si l'application ne filtre pas les entrées utilisateurs, un attaquant pourrait modifier la requete comme ceci :

SELECT nom, prenom FROM utilisateur WHERE username = 'admin'--

ainsi il aurait même pas besoin du mot de passe de la sessions administrateur pour pouvoir être connecté à sa session !

**Changement de page de diapo**

Identifier le type de la base de données :

Il est nécessaire d'identifier le type de base de données auquel nous sommes confrontés car en fonction de son type, les requetes devront être modifier.

par exemple pour concaténer des string c'est-à-dire assembler plusieurs string pour en former qu'un seul : 
Oracle         'foo'||'bar'
Microsoft     'foo'+'bar'
PostgreSQL     'foo'||'bar'
MySQL         'foo' 'bar' [Note the space between the two strings]
            CONCAT('foo','bar')

ect...

L’idée est de trouver quelle type de base de données nous avons affaire avant de commencer à dump des tables ou des columns.

# Partie écrite :

Dans la vidéo de présentation du cours nous avons introduit les bases sur les injections SQL. Dans cette partie nous verrons différentes technique basique sur les injections SQL. Vous avez la possibilité de voire la vidéo de démonstration pendant ou après avoir lu ce cours.

to do ce soir :

rapidement faire la cheat sheet

tourner la vidéo DVWA sqli 1

faire le montage rapide et l'upload

les types d'attaques possible : 

UNION

blind

time delay

# script vidéo TP SQLi :

Bonjour et bienvenue dans cette deuxième partie concernant les injections SQL. Certte fois-ci nous allons traiter un cas pratique avec la DVWA que nous avons d'ores et déjà installé sur notre KALI.

rdv dans un terminal

lancer la commande docker en sudo !

ouvrez un navigateur et entrez l'adresse "localhost"

mettre les login admin/password

créer ce qui est demandé

ce logger à nouveau admin/password

comprendre comment l'application fonctionne

procéder à la phase de detection (suivre la partie detection de la cheat sheet)

déterminer le type de base de données

tester des payload

trouver le bon payload
