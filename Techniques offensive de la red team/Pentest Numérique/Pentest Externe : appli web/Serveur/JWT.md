# Introduction et présentation en vidéo :

***script vidéo :***

Dans cette section, nous allons voir comment des problèmes de conception et une mauvaise gestion des JSON Web Token alias JWT peuvent rendre les applications web vulnérables à diverses attaques avec un impact fort qui pourrait être très précieuses pour une opération de Red Team.

Les **JSON Web token (JWTs)** sont un format **normalisé** pour envoyer des données JSON signées de manière cryptographique entre les systèmes.

Théoriquement, ils peuvent contenir n'importe quel type de données, mais le plus souvent
 ils sont utilisés pour envoyer des informations sur les utilisateurs dans le cadre de mécanismes d'authentification, de gestion de session et/ou de contrôle d'accès. Ces informations sur les utilisateurs sont dite "claims" (traduit littéralement par "réclamation" en français).

Contrairement aux token de session classiques, toutes les données dont un serveur a besoin sont stockées en client-side (côté client) dans le JWT.

Cela fait des JWTs un très bon choix pour les applications web hautement distribués où les utilisateurs doivent interagir de manière transparente avec plusieurs serveurs back-end.

Étant donné que les JWT sont implémenté dans des mechanismes crutial d'un service web, s'ils sont compromis ils peuvent potentiellement compromettre l'intégralité du site web et ses utilisateurs.

En réalité la spécification d'un JWT est initialement assez limité. En effet un JWT n'est enfaite qu'un format JSON pour représenter des "claims"  qui peut être transféré entre deux parties. Les spécifications d'un JWT est étendue par les spécifications JSON Web Signature où JWS et JSON Web Encryption où JWE.

En d'autres termes, un JWT est généralement un jeton JWS ou JWE. Lorsque l'on utilise le terme "JWT", il s'agit presque toujours d'un jeton JWS. Les JWE sont très similaires, sauf que le contenu  du jeton est chiffré plutôt que simplement encodé. 

JWT est donc un abus de language pour dire JWS.

Si vous n'êtes pas familier avec les JWT vous n'avez pas de soucis à vous faire, nous allons développer le fonctionnement de ces token mais aussi voire comment nous pouvons les exploiter lors d'opération de Red Team par exemple.

Composition des JWT :

composé de 3 parties :

- header : metadata : contient à minima algo  - *encoder en B64*

- payload (données) : les données nécessaires - *encoder en B64*

- signature : vérifie l'authenticité du token. En effet, le serveur qui émet le token génère généralement la signature en hachant le header et le payload. Dans certains cas, il chiffre également le résultat du hachage. Dans tous les cas, ce processus implique une clé de signature secrète. Ce mécanisme permet aux serveurs de vérifier qu'aucune des données contenues dans le jeton n'a été altérée depuis son émission:
  
  - Tout d'abord car la signature est directement dérivée du reste du jeton, la modification d'un seul octet de l'en-tête ou de la charge utile entraîne une signature non conforme.
  
  - Et puis sans connaître la clé de signature secrète du serveur, il ne devrait pas être possible de générer la signature correcte pour le header ou les données (payload).
  
  La signature peut se faire via des algorythme symétrique comme (HMAC SHA256) ou asymétrique (RSA-SHA256). La solidité du token repose sur le ou les secret(s) utilisés dans le JWT. Nous verrons cela dans la partie démo de ce cours.

Cette capture d'écran a été faite avec le site web JWT.io qui nous sera très utile pour la suite du cours.

Je vous laisse avec la partie écrite du cours qui contient des démontrations.

# Écrit :

# Place à la pratique

Dans cette partie nous allons nous interresser à l'exploitation des JSON Web Token. Dans un premier temps nous utiliserons hashcat pour faire du brute-force afin de trouver le secret du token. Puis nous finirons par exploiter une vulnérabilité qui consiste à modifier l'algorithme de hashage du token en none.

## Attaque par Brute-force

Dans cette première partie du cours écrit nous allons exploiter une attaque par brute-force sur un JSON Web Token.  En premier lieu nous allons voire et comparer les types d'attaques par brute-force qui sont exploitable sur des JWT. Puis nous présenterons les différents outils que nous pouvons utiliser pour opérer ces attaques et ensuite nous finirons par passer à la pratique avec un secret de JWT à craquer ! 

Les algorithmes de signature tels que HS256 utilisent une chaîne aléatoire comme clé secrète pour signer les jetons JSON Web Token (JWT). Il est important que cette clé ne soit pas facilement devinée ou forcée par un attaquant, car cela pourrait permettre à cet attaquant de créer des JWT avec des en-têtes et des données de charge de son choix et de les signer avec une signature valide en utilisant la clé secrète.

Lors de la mise en œuvre des applications JWT, les développeurs commettent parfois l'erreur d'oublier de modifier les secrets par défaut ou les secrets de remplacement. Dans ce cas, pour un attaquant il peut être très interressant de brute-forcer le secret d'un serveur en utilisant une liste de mots de secrets connus.

Les attaques par brute-force est une technique utilisée pour essayer de découvrir un mot de passe ou une clé en essayant toutes les combinaisons possibles jusqu'à ce qu'une 
combinaison valide soit trouvée. La durée de cette attaque dépend du nombre de combinaisons possibles, de la vitesse à laquelle l'attaquant peut tester chaque combinaison et des
 défenses mises en place pour protéger contre cette attaque. En l'occurence ici, sur les JWT, les défenses en places pour protéger le token des attaques par brute-force sont inexistante puisque on extrait le token pour faire l'attaque en local, sans avoir d'équipement de protection qui entrave l'attaque.

Il existe différents type d'attaque par brute-force :

**L 'attaque par masque** : Cette attaque consiste à essayer toutes les combinaison de mot possible mais sans forcément faire en sorte que la combinaison testé soit un mot. Par exemple si nous voulons tester une attaque par mot de passe uniquement composé de quatres caratères alphanumérique nous essayerons dans l'ordre : 

aaaa, aaab, aaac, [...], aaba, aaca, aada, etc...    

**Les attaques par dictionnaires** : cette attaque consite utiliser une liste pré-établie de mots de passe potentiels au lieu de générer toutes les combinaisons possibles de caractères. Cette liste, 
appelée dictionnaire, peut être constituée de mots de passe couramment utilisés, de noms, de dates ou de toute autre chaîne de caractères qui pourrait être utilisée comme mot de passe.

**Les attaques par rainbow table** : Les attaques par rainbow table sont une technique utilisée pour cracker des mots de passe en utilisant une table de hachage pré-calculée. Une 
rainbow table est une grande table de données qui contient des hachages de mots de passe possibles et leurs valeurs de hachage correspondantes.  Ces attaques sont généralement plus rapides que l'attaque par brute-force standard, car elles ne nécessitent pas de générer et de tester toutes les combinaisons possibles de caractères. Cependant, elles nécessitent une 
grande quantité de stockage pour stocker tous les hachages pré-calculés, et elles ne sont efficaces que si le mot de passe est présent dans la rainbow table utilisée. 

Pour opérer ces attaques nous pouvons utiliser différents logiciels reconnu ou faire un logiciel de brute-force nous-même. 

Pour des soucis de temps nous allons utiliser un logiciel reconnu. Les trois logiciels les plus connu et les plus efficaces pour faire cela sont les suivants : jwt-cracker ([GitHub - lmammino/jwt-cracker: Simple HS256 JWT token brute force cracker](https://github.com/lmammino/jwt-cracker)), JohnTheRipper ([GitHub - openwall/john: John the Ripper jumbo - advanced offline password cracker, which supports hundreds of hash and cipher types, and runs on many operating systems, CPUs, GPUs, and even some FPGAs](https://github.com/openwall/john)) et pour finir hashcat ([hashcat - advanced password recovery](https://hashcat.net/hashcat/)).

Nous allons utiliser hashcat pour opérer cette attaque car c'est le logiciel reconnu comme étant le plus rapide mais il est aussi très polyvalent. En effet vous pouvez faire des attaques par brute-force de nombreux types avec des vitesses record. Il est possible d'utiliser le GPU pour faire les calculs nécessaires à l'atttaque ce qui augmente grandement le nombre de hash par second disponible en ressource.



Nous vous demandons de bien vouloire aller sur votre Machine virtuelle Kali installé et utilisé précédemment.

Une fois sur votre machine virtuelle vous pouvez ouvrir un terminale et entrez la commande suivante :

`hashcat -b`

![](/home/tristan/.config/marktext/images/2023-01-10-17-33-18-image.png)

Cette commande permet de faire des benshmark (test de performmance) et permet aussi de voire que le logiciel est bien configuré.

Si vous avez pas d'erreur au lancement de hashcat passer à la suite du cours, au cas contraire nous vous invitons à désinstaller/réinstaller hashcat ou à visiter le site https://hashcat.net



Désormais il nous faut notre liste de mot pour faire notre attaque par dictionnaire. Nous allons utiliser la wordlist déjà présente sur toutes les VM Kali : rockyou.txt

rockyou.txt est une liste de plus de 14 millions de mots de passe les plus utilisés. 

Comme nous l'avons cité plus haut elle est disponible nativement sur toutes les machines virtuelles Kali. Pour y accéder nous devons d'abord l'extraire avec la commande suivante :

`sudo gunzip /usr/share/wordlist/rockyou.txt.gz`

Nous pouvons désormais démarrer notre attaque !

voici le JWT avec le secret de la signature à craquer :

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVSUQiOiIxMjM0NTY3ODkwMTIzIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6InVzZXIiLCJleHAiOjE2NDgwMzcxNjR9.xMP8j0zLLWoNAunxCGe2g36HmSQLJoc0Tk-R28j3M_Q`

Vous devez copier coller ce JWT dans un fichier. Vous pouvez l'appeler `JWT.txt`

Désormais nous pouvons lancer la commande hashcat suivante :

- `hashcat -a 0 -m 16500 <jwt> <wordlist>`
  
  `-a` désigne le mode utilisé, ici une attaque par dictionnaire
  
  `-m` désigne le type de hash à déchiffrer. 16500 correspond aux JWT.
  
  `<jwt>` est le chemin vers le fichier contenant le JWT
  
  `<wordlist>` est le chemin complet vers la wordlist utilisé (dans notre cas rockyou.txt)



La commande complète resseblera donc à cela :

`hashcat -a 0 -m 16500 jwt.twt /usr/share/wordlist/rockyou.txt`



password : `Passw0rd`

## démo modifier l'algo en "none" => voire la CVE

Dans cette partie nous allons utiliser une faille présente si les JWT sont mal implémenté : le changement d'algorithme en "none". 

pour cela nous pouvons prendre le même JWT que toute à l'heure :

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVSUQiOiIxMjM0NTY3ODkwMTIzIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6InVzZXIiLCJleHAiOjE2NDgwMzcxNjR9.xMP8j0zLLWoNAunxCGe2g36HmSQLJoc0Tk-R28j3M_Q`

Dans un premier temps il faudra que nous décodions les deux parties du JWT. Pour cela ouvrez un terminal sur votre machine virtuelle Kali et lancer la commande suivante :

`echo -n "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d`

<img src="file:///home/tristan/.config/marktext/images/2023-01-10-19-59-24-image.png" title="" alt="" width="559">

Ce qui nous donne une erreur. Cela est normal car la commande `base64 -d` décode du base64 et non du base64URL ce qui est le case des JWT. Le message d'erreur provient donc juste du fait que le dernier caractère n'est pas un `=` ce qui est le caractère de limite pour le base64. C'est la seul différence entre du base64 et du base64URL, le caractère qui définie la fin de chaine.

Nous obtenons donc le string suivant :

`{"alg":"HS256","typ":"JWT"}`

Notre objectif est de profiter d'une erreur d'implémentation des JWT en changeant l'lagorythme utilisé en `none`. Il nous suffit donc de changer la variable `alg` en `none`. Cela peut-être fait avec la commande echo concaténé avec la commande base64 : 

`echo -n '{"alg":"none","typ":"JWT"}' | base64`

Ce qui nous donne le résultat :

`eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0=`

Comme tout à l'heure lors du décodage, nous devons prendre en compte que l'encodage a été fait en base64 et non base64URL. Il nous suffit de supprimer le dernier caractère `=` afin de le rendre valide pour un JWT.

Nous avons plus qu'à remplacer la partie modifier dans le JWT et le tour est joué ! Désormais nous pouvons changer les variables de la partie payload en ce que nous voulons afin d'exploiter cette vulnérabilité.

Avec la variable "role" nous pourrions monter en privilège sur l'application et devenir administrateur en changeant la valeur de cette variable de "user" à "admin". 

Pour toutes ces opérations vous pouvez vous aider du debugger du site https://jwt.io 
